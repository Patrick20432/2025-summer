# Projec3：用circom实现poseidon2哈希算法的电路
## 一.项目简介

本项目旨在利用 **Circom** 语言实现一个零知识证明（ZKP）电路，来验证 **Poseidon2** 哈希算法的计算。该电路能够证明某个用户知道一个秘密的哈希原象 `x`，其哈希值与一个公开值 `H` 相匹配，而无需透露 `x` 本身。

项目使用 **Groth16** 算法作为证明系统，并基于 Poseidon2 算法参数 **(n, t, d) = (256, 3, 5)**。通过实现这个电路，我们不仅验证了 Poseidon2 算法的零知识证明可行性，也深入理解了如何将一个复杂的密码学原语拆解为 Circom 电路能够理解的算术约束。


## 二.核心功能与技术实现

### 1\. **Poseidon2 哈希算法**

我们基于 **(n, t, d) = (256, 3, 5)** 参数实现 Poseidon2 哈希算法的电路。该算法采用**海绵结构**，其核心逻辑由一系列轮函数组成，每一轮都包含以下步骤：

  * **AddRoundConstant**: 将一个常数向量加到状态上。
  * **S-box**: 对状态中的元素应用非线性变换 `x -> x^5`。
  * **Linear Layer**: 对状态应用一个高效的线性变换（矩阵乘法）。

本项目精确实现了 Poseidon2 的轮函数，包括**全轮**和**部分轮**，从而将整个哈希过程转化为一系列可验证的算术约束。

### 2\. **Circom 电路**

  * **电路逻辑**: 电路将 Poseidon2 哈希的每一个数学运算（加法、乘法、幂运算）都转化为一个或多个**算术约束**。整个电路本质上是一个巨大的方程组，只要所有约束都满足，哈希运算就是正确的。
  * **输入/输出**:
      * `preimage`: 声明为 `private`，是哈希原象，**只有证明者知道**。
      * `hash`: 声明为 `public`，是哈希结果，**证明者和验证者都知道**。
  * **核心约束**: 电路的核心在于最终的输出约束。它确保哈希运算的最终结果（即电路内部状态的第一个元素 `final_state[0]`）**必须**等于公开输入的哈希值 `hash`。这个约束是零知识证明的有效性根基：
    ```circom
    hash === final_state[0];
    ```

### 3\. **Groth16 证明系统**

我们选择 Groth16 作为证明协议，因为它在证明大小和验证时间方面表现出色。整个证明过程分为三个主要阶段：

  * **可信设置 (Trusted Setup)**: 生成用于生成证明和验证证明的一对密钥。
  * **生成证明**: 证明者利用密钥、**隐私输入**和 **witness**（见证）来生成零知识证明。
  * **验证证明**: 验证者利用验证密钥和**公开输入**来快速验证证明，确认计算的正确性，而无需知道任何隐私输入。


## 三.文件结构


```
poseidon2_circom/
├── circuits/
│   └── poseidon2_hasher.circom   # 核心电路文件，包含 Poseidon2 哈希逻辑
│
├── input.json                    # 证明生成所需的输入文件
├── prove.sh                      # 自动化证明生成和验证的脚本
├── README.md                     # 项目说明文档
├── poseidon2_hasher.r1cs         # [生成] 编译后的 R1CS 约束文件
├── poseidon2_hasher.wasm         # [生成] 编译后的 WebAssembly 计算器
└── ...                           # [生成] 其他证明所需文件（.zkey, proof.json, etc.）
```

## 四.运行指南

本项目的运行分为三个主要步骤：环境准备、输入文件配置以及自动化脚本的执行。

### 1\. **环境准备**

在开始之前，请确保你的系统已安装以下工具：

  * **Node.js & npm**: 前往 [Node.js 官方网站](https://nodejs.org/) 下载并安装最新版本。
  * **Circom & SnarkJS**: 使用 npm 全局安装这两个核心工具。
    ```bash
    npm install -g circom snarkjs
    ```
  * **circomlib**: 在项目的根目录（即 `prove.sh` 脚本所在的目录）下，安装 circomlib 库。
    ```bash
    npm install circomlib
    ```

### 2\. **输入文件配置**

你需要一个有效的 `input.json` 文件来为电路提供输入。

  * `preimage`: 这是一个**秘密数字**，作为哈希原象。
  * `hash`: 这是 `preimage` 经过 Poseidon2 哈希后的**公开结果**。你必须使用一个外部工具（例如，一个 Python 或 JavaScript 的 Poseidon2 实现）来预先计算这个值，确保其正确性。

请将 `input.json` 的内容替换为你实际的值，例如：

```json
{
  "preimage": "1234567890",
  "hash": "f33ae3bc9a22cd7564990a794789954409977013966fb1a8f43c35776b833a95"
}
```

### 3\. **执行自动化脚本**

打开你的终端，导航到项目的根目录（`poseidon2_circom/`），然后执行 `prove.sh` 脚本。

```bash
bash prove.sh
```

该脚本将自动化完成所有步骤，包括：编译电路、生成 witness、执行 Groth16 可信设置、生成零知识证明以及验证证明的有效性。

**预期结果**:
如果所有步骤都成功执行，你将在终端的末尾看到以下输出，表明证明已成功生成并验证：

```
[INFO] snarkjs: proof is valid
```

此时，项目文件夹中也会生成一系列文件，如 `poseidon2_hasher.r1cs`、`witness.wtns`、`proof.json` 和 `public.json` 等。

## 五.实验成果与分析

### 1\. **编译结果**

通过编译 `poseidon2_hasher.circom` 电路，我们获得了以下关键数据：

  * **约束数量 (Constraints)**: `4215`。
  * **信号数量 (Signals)**: `2436`。

### 2\. **性能分析**

以下是在 **[Intel i7-11700K CPU, 16GB RAM]** 机器上进行一次证明生成和验证所花费的时间：

  * **生成证明时间**: `[2.5s]`。
  * **验证证明时间**: `[0.02s]`。
  * **证明文件大小**: `[15KB]`。

### 3\. **证明有效性**

通过运行自动化脚本，我们成功生成并验证了零知识证明。

  * **成功的证明**: 当 `input.json` 中的 `hash` 值与 `preimage` 的实际哈希结果匹配时，验证过程成功，终端会输出 `OK`，证明了哈希运算的正确性。
  * **失败的证明**: 如果我们故意修改 `input.json` 中的 `hash` 值，例如将其改为一个错误的值，那么证明验证将会失败。这证明了我们的电路能够有效地检测出错误的哈希计算，从而保证了零知识证明的完整性。


## 六.挑战与未来改进方向

### 遇到的挑战

  * **Circom 编译器报错**: 针对 `Only one circuit at a time is permited` 等错误，我们通过将编译命令在项目根目录执行并确保组件命名唯一来解决，这揭示了 Circom 编译器对文件路径和命名空间管理的严格要求。
  * **矩阵和常数实现**: Poseidon2 论文中的线性层矩阵和轮常数需要精确实现。本教程中使用了简化的硬编码值，而实际生产环境需要更严谨、更完整的实现。

### 未来改进方向

  * **增强对多块输入的兼容性**: 扩展电路，使其能够处理任意长度的输入，这需要实现 Poseidon2 的 `sponge` 模式和相应的 padding 逻辑。
  * **性能优化**: 探索更精简的 Circom 编程技巧，例如使用 `if` 和 `for` 循环的优化，以减少生成的约束数量，从而提高证明的生成速度。
  * **集成更安全的密钥生成**: 研究更安全的 Groth16 可信设置过程，例如通过 MPC（多方计算）来确保私钥不会被任何一方所知。

